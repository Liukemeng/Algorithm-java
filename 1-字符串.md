###                                               字符串算法

#### 知识点：

1. 注意到String和StringBuffer的相同点和区别；

   ​	总体思想，尽可能用StringBuffer，因为可以toString()转为String；

   1. 相同点：charAt()、length()、isEmpty()、substring()、
   2. 不同点：
      1. 追加元素：str.concat(String str)只能是String; strbuf.append(T t)可以是基本数据类型、char[] 、CharSequence；
      2. 替换元素：str.replace(char old, char new)、str.replace(CharSequence old, CharSequence new),他的参数是char和CharSequence; strbuf.replace(int begin, int end, String str)，它的参数是位置和String;
      3. StringBuffer有删除功能、String没有：strbuf.deleteCharAt(int index); strbuf.delete(int begin, int end);
      4. StringBuffer有修改某位置的功能，String没有：strbuf.setCharAt (int index, char ch);
      5. StringBuffer有翻转的功能，String没有：strbuf.reverse();
      6. String 有contains()功能，StringBuffer没有：str.contains (CharSequence cs)
      7. String有trim()功能，StringBuffer没有：str.trim();
      8. String有转为大小写的功能，StringBuffer没有： str.toLowerCase(), str.toUpperCase();

2. 常见解题思路：  计数法（统计字符直接用int[]，统计String可以用map）、哈希表，栈，动态，位运算，但是更多的是根据题意自己推断过程。

3. 比较字符串是否相等用str1.equals(str2)，不用写个函数一个字符一个字符的比较。



#### 基本例题：

1. <u>**翻转句子**</u>：输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串"I am a student. "，则输出"student. a am I"。

   **解题思路**：String分割为String[]数组，然后通过Arrays.asList()变为list，然后再用Collections.reverse()进行翻转；

   ```java
   class Solution {
       public String reverseWords(String s) {
           if(s==null||s.length()==0){
               return s;
           }
           
           StringBuffer res=new StringBuffer();
           String[] strArray=s.trim().split(" ");
           //注意Arrays.asList()将数组转为list的时候，底层存储还是用的原来的数组；所以可以总结出来，Arrays和Collections工具类，他们都是在原来的数据结构上处理，不会生成新的数据。
           Collections.reverse(Arrays.asList(strArray));
           for(String str:strArray){
               if(!str.equals("")){
                   res.append(str).append(" ");
               }   
           }
           return res.toString().trim();//去掉尾部的空格
       }
   }
   ```

2. <u>**翻转句子中的单词**</u>：给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。示例 1:

   输入: "Let's take LeetCode contest"
   输出: "s'teL ekat edoCteeL tsetnoc" 

   **解题思路**：通过String的split()将str变成String[], 然后再将str变成StringBuffer，用它的reverse()方法翻转即可。

   ```java
   class Solution {
       public String reverseWords(String s) {
           String[] strArray=s.trim().split(" ");
           StringBuffer res=new StringBuffer();
           for(int i=0;i<strArray.length;i++){
               StringBuffer strBuf=new StringBuffer(strArray[i]);
               strBuf.reverse();
               res.append(strBuf).append(" ");
           }
           return res.toString().trim();
       }
   }
   ```
   

   
3. <u>**替换空格**</u>：请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

   **解题思路1**：采用String中的replace(CharSequence old, CharSequence  new)方法直接换；

   ```java
   public class Solution {
       public String replaceSpace(StringBuffer str) {
           if(str==null||str.length()==0){
               return str
           }
           return str.toString().replace(" ","%20");
       }
   }
   
   ```

   **解题思路2**：双指针法

   ```java
   public class Solution {
       public String replaceSpace(StringBuffer str){
           int p1=str.length()-1;//P1 指向字符串原来的末尾位置
           for(int i=0;i<=p1;i++){
               if(str.charAt(i)==' '){  //注意这里是字符，单引号
                   str.append("  ");// 这里是字符串，双引号,注意这里是加两个字符
               }
           }
           
           int p2=str.length()-1;
           while(p1>=0){
               if(str.charAt(p1)==' '){
                   str.setCharAt(p2--,'0');
                   str.setCharAt(p2--,'2');
                   str.setCharAt(p2--,'%');
               }else{
                   str.setCharAt(p2--,str.charAt(p1));
               }
               p1--;
           }
           return str.toString();  
       }
   }
   
   ```

4. <u>**单词间的最小距离**</u>：有个内含单词的超大文本文件，给定任意两个单词，找出在这个文件中这两个单词的最短距离(相隔单词数)。如果寻找过程在这个文件中会重复多次，而每次寻找的单词不同，你能对此优化吗?

   示例：输入：words = ["I","am","a","student","from","a","university","in","a","city"], word1 = "a", word2 = "student"；输出：1。

   **解题思路**：也是类似**双指针**的思路。

   ```java
   class Solution {
       public int findClosest(String[] words, String word1, String word2) {
           int p1=-1,p2=-1;
           int dis=Integer.MAX_VALUE;
           for(int i=0;i<words.length;i++){
               if(word1.equals(words[i])){
                   p1=i;
                   if(p2!=-1){
                       dis=Math.min(dis,Math.abs(p1-p2));
                   }
               }
               
               if(word2.equals(words[i])){
                   p2=i;
                   if(p1!=-1){
                       dis=Math.min(dis,Math.abs(p1-p2));
                   }
               }
           }
           return dis;
       }   
   }
   ```

5. <u>**字符流中第一个不重复的字符**</u>：找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符"go"时，第一个只出现一次的字符是"g"。当从该字符流中读出前六个字符“google"时，第一个只出现一次的字符是"l"。如果当前字符流没有存在出现一次的字符，返回#字。

   **解题思路**:

   ```java
   import java.util.*;
   public class Solution {
       //Insert one char from stringstream
       int[] count=new int[125];
       Queue<Character> queue=new LinkedList<>();
       
       public void Insert(char ch){
           count[ch]++;
           queue.offer(ch);
       }
       
     //return the first appearence once char in current stringstream
       public char FirstAppearingOnce(){
           while(!queue.isEmpty()){
               if(count[queue.peek()]==1){
                   return queue.peek();
               }else{
                   queue.remove();
               }
           }
           return '#';
       }
   }
   
   
   ```

6. <u>**字符串中出现一次的字符**</u>：在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）。

   **解题思路**：计数法

   ```java
   public class Solution {
       public int FirstNotRepeatingChar(String str) {
           if(str.length()==0){
               return -1;
           }
           int[] count=new int[125];//A-Z 65-90   a-z 97-122
           for(int i=0;i<str.length();i++){
               count[str.charAt(i)]++;
           }
           for(int i=0;i<str.length();i++){
               if(count[str.charAt(i)]==1){
                   return i;
               }
           }
           return -1;  
       }
   }
   
   ```

7. <u>**自定义字符串的排序**</u>：字符串S和 T 只包含小写字符。在S中，所有字符只会出现一次。S 已经根据某种规则进行了排序。我们要根据S中的字符顺序对T进行排序。更具体地说，如果S中x在y之前出现，那么返回的字符串中x也应出现在y之前。返回任意一种符合条件的字符串T。示例: 输入:S = "cba"
   T = "abcd"；输出: "cbad"。

   **解题思路**：其实还是用的计数法。1、把T各个元素个数统计出来；2、按照S的顺序先把T中对应的元素加到res中；3、然后把T中不在S中的元素加到res中。

   ```java
   class Solution {
       public String customSortString(String S, String T) {
           int[] count=new int[26];
           for(int i=0;i<T.length();i++){
               count[T.charAt(i)-'a']++;
           }
   
           StringBuffer res=new StringBuffer();
           for(int i=0;i<S.length();i++){
               int num=count[S.charAt(i)-'a'];
               if(num!=0){
                   for(int j=0;j<num;j++){
                       res.append(S.charAt(i));
                   }
               }
               count[S.charAt(i)-'a']=0;   
           }
   
           for(int i=0;i<count.length;i++){
               if(count[i]!=0){
                   for(int j=0;j<count[i];j++){
                       res.append((char)(i+'a'));
                   }
               }
           }
           return res.toString();
       }
   }
   ```

8. <u>**制造字母异位词的最小步数**</u>：给你两个长度相等的字符串 s 和 t。每一个步骤中，你可以选择将 t 中的 任一字符 替换为 另一个字符。返回使 t 成为 s 的字母异位词的最小步骤数。字母异位词 指字母相同，但排列不同（也可能相同）的字符串。示例 1： 输出：s = "bab", t = "aba"； 输出：1。
   提示：用 'b' 替换 t 中的第一个 'a'，t = "bba" 是 s 的一个字母异位词。

   ```java
   class Solution {
       public int minSteps(String s, String t) {
           int[] cs=new int[26];
           int[] ct=new int[26];
           for(int i=0;i<s.length();i++){
               cs[s.charAt(i)-'a']++;
               ct[t.charAt(i)-'a']++;
           }
           int res=0;
           for(int i=0;i<cs.length;i++){
               if(cs[i]>ct[i]){
                   res+=cs[i]-ct[i];
               }
           }
           return res;
   
       }
   }
   ```

   

9. <u>**变位词组**</u>：编写一种方法，对字符串（均为小写字母）数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。

   注意：本题相对原题稍作修改

   示例:

   输入: ["eat", "tea", "tan", "ate", "nat", "bat"],
   输出:
   [
     ["ate","eat","tea"],
     ["nat","tan"],
     ["bat"]
   ]

   **解题思路**：哈希表的思想。

   ​		把strs中的各个元素进行处理，是的变为词组变成相同的格式，然后插入到map里面。（计数法）

   ​		map<String,List<String>>,key为变位词组处理后相同的那个结果，value是此变为词组包含的元素；

     	把map中的value放到res中

   ```java
   class Solution {
       public List<List<String>> groupAnagrams(String[] strs) {
           List<List<String>> res=new ArrayList<>();//注意这里是怎么new的
           Map<String,List<String>> map=new HashMap<>();
           for(int i=0;i<strs.length;i++){
               String str=process(strs[i]);
               if(!map.containsKey(str)){
                   map.put(str,new ArrayList<String>());
               }
               map.get(str).add(strs[i]);
           }
   
           //map的遍历方法
           for(String str:map.keySet()){
               res.add(map.get(str));
           }
           return res;
       }
   
       public String process(String str){
           int[] count=new int[26];
           for(int i=0;i<str.length();i++){
               count[str.charAt(i)-'a']++;
           }
           StringBuffer strbuf=new StringBuffer();
           for(int i=0;i<count.length;i++){
               int num=count[i];
               for(int j=0;j<num;j++){
                   strbuf.append((char)(i+'a'));
               }
           }
           return strbuf.toString();
       } 
   }
   ```
   
   

10. <u>**把字符串转为整数**</u>：将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。输入一个字符串,包括数字字母符号,可以为空。

   示例：+2147483647—>2147483647  1a33->0

   **解题思路**：for循环判断各个字符是不是符合条件

   ​				注意：1、第一个元素需要特殊处理，因为可能是+ - 数字三种情况，是数字的话，不应该是0；

   ​                            2、整数和负数越界的问题；

   ```java
   public class Solution {
       public int StrToInt(String str) {
           if(str==null||str.length()==0){
               return 0;
           }
           
           int first=1;
           char[] ch=str.toCharArray();
           int[] res=new int[ch.length];
           
           //处理第一个元素
           if(ch[0]=='+'){
               res[0]=0;
           }else if(ch[0]=='-'){
               res[0]=0;
               first=-1;
           }else if(ch[0]>'0'&&ch[0]<='9'){
               res[0]=ch[0]-'0';
           }else{
               return 0;
           }
           //处理之后的元素
           for(int i=1;i<ch.length;i++){
               if(ch[i]>='0'&&ch[i]<='9'){
                   res[i]=ch[i]-'0';
               }else{
                   return 0;
               }
           }
           //处理溢出
           int max=Integer.MAX_VALUE;
           int min=Integer.MIN_VALUE;
           //计算结果
           int result=0;
           for(int i=res.length-1;i>=0;i--){
               if(first==1){//正数的时候
                   max-=res[i]*(int)Math.pow(10,res.length-1-i);
               }else{//负数的时候
                   min+=res[i]*(int)Math.pow(10,res.length-1-i);
               }
               result+=res[i]*(int)Math.pow(10,res.length-1-i);
           }
           
           if(min<=0&&max>=0){//不越界的是时候
               return first*result;
           }else{
               return 0;
           }        
       }
   }
   
   ```

11. <u>**正则表达式**</u>：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100","5e2","-123","3.1416"和"-1E-16"都表示数值。 但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是。

    ```java
    import java.util.regex.Pattern;
    public class Solution {
        public boolean isNumeric(char[] str) {
            String pattern="^[-+]?\\d*(\\.\\d+)?([eE][+-]?\\d+)?$";//e和后面的+或者-符号一起处理
            String strr=new String(str);
            return Pattern.matches(pattern,strr);
            
        }
    }
    ```

12. <u>**字符串相加**</u>：给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。注意：

    num1 和num2 的长度都小于 5100.
    num1 和num2 都只包含数字 0-9.
    num1 和num2 都不包含任何前导零。
    你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。

    **解题思路**：1、注意进位；2、注意最后的时候进位。

    ```java
    class Solution {
        public String addStrings(String num1, String num2) {
            
            StringBuffer strBuf=new StringBuffer();
            int carry=0;
            int i=num1.length()-1;
            int j=num2.length()-1;
            while(i>=0||j>=0){
                int value=carry;
                if(i>=0){
                    value+=num1.charAt(i--)-'0';
                }
                if(j>=0){
                    value+=num2.charAt(j--)-'0';
                }
                carry=value/10;
                value=value%10;
                strBuf.append(value);
            }
            if(carry==1){
                strBuf.append(carry);
            }
            return strBuf.reverse().toString();
        }
    }
    ```

13. <u>**大数相减**</u>：输入两个只有数字的字符串，然后计算两个数的差，并返回字符串。

    **解题思路**：首先，要判断减数和被减数哪一个位数长，被减数位数长是正常减；减数位数长，则被减数减减数，最后还要加上负号；两数位数长度相等时，最好比较一下哪一个数字大，否则负号处理会很繁琐，用大的减去小的，最后加上负号；

    其次，处理每一项时要，如果前一位相减有借位，就先减去上一位的借位，无则不减；再去判断是否能够减开被减数，如果减不开，就要借位后再去减，同时置借位为1，否则置借位为0。

    ```java
    package string;
    
    public class MyString {
        public static void main(String[] args) {
            String s1="1";
            String s2="608";
            System.out.println(subtraction(s1,s2));
            System.out.println(608-567);
        }
    
        public static String subtraction(String s1,String s2){
            //特列
            if((s1==null||s1.length()==0)&&s2==null||s2.length()==0){
                return "0";
            }
            if(s1==null||s1.length()==0){
                StringBuffer res=new StringBuffer(s2);
                res=res.reverse().append('-');
                return res.reverse().toString();
            }
            if(s2==null||s2.length()==0){
                return s1;
            }
    
            //正常逻辑
            StringBuffer res=new StringBuffer();
            int borrow=0;
            int flag=1;
            //使得s1为长的或者大的字符串
            if(s2.length()>s1.length()){
                String tem=s1;
                s1=s2;
                s2=tem;
                flag=-1;
            }
            if(s1.length()==s2.length()&&s2.compareTo(s1)>0){
                    String tem=s1;
                    s1=s2;
                    s2=tem;
                    flag=-1;
            }
            //开始计算
            int l1=s1.length()-1;
            int l2=s2.length()-1;
            while(l1>=0&&l2>=0){
                int value=borrow+s1.charAt(l1)-'0';
                if(value<s2.charAt(l2)-'0'){
                    borrow=-1;
                    value+=10;
                }else{
                    borrow=0;
                }
                res.append(value-(s2.charAt(l2)-'0'));
                l1--;
                l2--;
            }
            while(l1>=0){
                int value=s1.charAt(l1)-'0'+borrow;
                res.append(value);
                borrow=0;
                l1--;
            }
            //处理头部相减出现的零
            int ls=res.length()-1;
            while(res.charAt(ls)=='0'){
                res.deleteCharAt(ls);
                ls--;
            }
            if(flag==-1){
                res.append("-");
            }
            return res.reverse().toString();
        }
    }
    
    ```

14. <u>**大数相乘**</u>：输入两个只有数字的字符串，然后计算两个数的乘积，并返回字符串。

    **解题思路**：https://blog.csdn.net/antgan/article/details/51044098
    输入字符串，转成char数组，转成int数组。采用分治思想，每一位的相乘;
    \* 公式：AB*CD = AC (BC+AD) BD
    \* 然后从后到前满十进位，顺序如右(BD,(BC+AD),AC)。

    ```java
    import java.util.Scanner;
    
    /**
     * 大数相乘
     * @author Ant
     *
     */
    public class BigMultiply {
    
        /**
         * 大数相乘基本思想，输入字符串，转成char数组，转成int数组。采用分治思想，每一位的相乘;<br>
         * 公式：AB*CD = AC (BC+AD) BD , 然后从后到前满十进位(BD,(BC+AD),AC)。
         * @param num1
         * @param num2
         */
        public String multiply(String num1, String num2){
            //把字符串转换成char数组
            char chars1[] = num1.toCharArray();
            char chars2[] = num2.toCharArray();
    
            //声明存放结果和两个乘积的容器
            int result[] = new int[chars1.length + chars2.length];
            int n1[] = new int[chars1.length];
            int n2[] = new int[chars2.length];
    
            //把char转换成int数组，为什么要减去一个'0'呢？因为要减去0的ascii码得到的就是实际的数字
            for(int i = 0; i < chars1.length;i++)
                n1[i] = chars1[i]-'0';
            for(int i = 0; i < chars2.length;i++)
                n2[i] = chars2[i]-'0';
    
            //逐个相乘，因为你会发现。AB*CD = AC(BC+AD)BD , 然后进位。
            for(int i =0 ; i < chars1.length; i++){
                for(int j =0; j < chars2.length; j++){
                    //这里是最关键的点。
                    result[i+j]+=n1[i]*n2[j];
                }
            }
    
            //满10进位，从后往前满十进位
            for(int i =result.length-1; i > 0 ;i--){
                result[i-1] += result[i] / 10;
                result[i] = result[i] % 10;
            }
    
            //转成string并返回
            String resultStr = "";
            for(int i = 0; i < result.length-1; i++){
                resultStr+=""+result[i];
            }
            return resultStr;
        }
    
        public static void main(String[] args) {
            BigMultiply bm = new BigMultiply();
            System.out.println("-----输入两个大数------");
            Scanner scanner = new Scanner(System.in);
            String num1 = scanner.next();
            String num2 = scanner.next();
            String result = bm.multiply(num1, num2);
            System.out.println("相乘结果为："+result);
            scanner.close();
        }
    }
    ```

    

15. <u>**字符串的压缩**</u>：字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。

    **解题思路**：一遍遍历即可

    ```java
    class Solution {
        public String compressString(String S) {
            int n=S.length();
            StringBuffer res=new StringBuffer();
    
            for(int i=0;i<n;){
                char ch=S.charAt(i);
                res.append(ch);
                int count=0;
                while(i<n&&S.charAt(i)==ch){
                    count++;
                    i++;
                }
                res.append(count);
            }
            if(res.length()<n){
                return res.toString();
            }else{
                return S;
            }
        }
    }
    ```

16. <u>**长按键输入**</u>：你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，而字符可能被输入 1 次或多次。你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。示例 1：

    输入：name = "alex", typed = "aaleex"； 输出：true。
    **解题思路**：把name和typed，都变成a1l1e1x1,a2l1e2x1的这种形式，然后typed在对应位置的元素数量应该比name大。注意单个字符要是超过十个的话，用StringBuffer就不行了，12他占两个字符。所以需要用数组来处理int[]。

    ```java
    package string;
    
    import java.util.Arrays;
    
    public class MyString {
        public static void main(String[] args) {
            String s1="alex";
            String s2="aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaleex";
            System.out.println(isLongPressedName(s1,s2));
    
        }
    
        public static boolean isLongPressedName(String name, String typed) {
            if(name==null&&typed==null||name.length()==0&&typed.length()==0){
                return true;
            }
            if(name==null||typed==null||name.length()==0||typed.length()==0){
                return false;
            }
    
            int n1=name.length();
            int n2=typed.length();
    
            int[] res1=new int[2*n1];
            int[] res2=new int[2*n2];
            int write1,write2;
    
            write1=process(name,res1);
            write2=process(typed,res2);
            
            if(write1!=write2){
                return false;
            }
    
            for(int i=0;i<write1;i++){
                if(res1[i]!=res2[i]&&res1[i]>res2[i]){
                    return false;
                }
            }
            return true;
        }
        //对字符串进行处理，结果存到res里面，并返回res的实际长度。
        public static int process(String str,int[] res){
            int n=str.length();
            int write=0;
            for(int i=0;i<n;i++){
                char ch=str.charAt(i);
                int count=0;
                while(i<n&&ch==str.charAt(i)){
                    count++;
                    i++;
                }
                res[write++]=ch;
                res[write++]=count;
            }
            return write;
        }
    }
    ```

17. （看）<u>**另一种字符串压缩**</u>：给定一组字符，使用原地算法将其压缩。压缩后的长度必须始终小于或等于原数组长度。数组的每个元素应该是长度为1 的字符（不是 int 整数类型）。在完成原地修改输入数组后，返回数组的新长度。

    示例 1：输入：["a","a","b","b","c","c","c"]； 输出：返回6，输入数组的前6个字符应该是：["a","2","b","2","c","3"]；

    示例 2：输入：["a","b","b","b","b","b","b","b","b","b","b","b","b"]；输出：返回4，输入数组的前4个字符应该是：["a","b","1","2"]。说明：由于字符"a"不重复，所以不会被压缩。"bbbbbbbbbbbb"被“b12”替代。

    **解题思路**：双指针法，一个read指针，用来遍历并计算相同元素的个数，一个write指针，用来往chars里面写；

    ```java
    class Solution {
        public int compress(char[] chars) {
            int write=0;
            int n=chars.length;
    
            //i就是read指针
            for(int i=0;i<n;){
                char ch=chars[i];
                int count=0;
                while(i<n&&chars[i]==ch){
                    count++;
                    i++;
                }
                chars[write++]=ch;
                //这里处理的很巧妙，将int转为String然后在转为char[]
                if(count!=1){
                    for(char c:String.valueOf(count).toCharArray()){
                        chars[write++]=c;
                    }
                }
            }
            return write;
        }
    }
    ```

18. **（背）**<u>**重复的子字符串**</u>：给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。示例 1: 输入: "abab"；输出: True。

    **解题思路**：假设字符串由n个子串构成,则拼接后的子串为2n个,掐头去尾后为2n-2个,如果此时的字符串至少包含一个原字符串,则说明至少包含n个子串,则2n-2>=n,n>=2.则说明该字符串是周期性结构,最少由两个子串构成.如果一个都不包含,即不包含n个子串,则说明2n-2<n,n<2,即n为1,也就是不符合周期性结构。

    ```java
    class Solution {
        public boolean repeatedSubstringPattern(String s) {
            if(s==null||s.length()==0){
                return false;
            }
            
            String ss=s+s;
            return ss.substring(1,ss.length()-1).contains(s);
        }
    }
    ```

19. <u>**验证回文串**</u>：给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

    说明：本题中，我们将空字符串定义为有效的回文串。

    示例 1: 输入: "A man, a plan, a canal: Panama"； 输出: true。

    ```java 
    class Solution {
        public boolean isPalindrome(String s) {
            if(s==null||s.length()==0){
                return true;
            }
            //进行预处理：剔除无关字符，都转为小写
            int n=s.length();
            StringBuffer strBuf=new StringBuffer();
            for(int i=0;i<n;i++){
                if(s.charAt(i)>='a'&&s.charAt(i)<='z'|| s.charAt(i)>='A'&&s.charAt(i)<='Z'|| s.charAt(i)>='0' &&s.charAt(i)<='9'){
                    strBuf.append(s.charAt(i));
                }
            }
            
            String s1=strBuf.toString().toLowerCase();
            int l=0;
            int r=s1.length()-1;
            //判断回文
            while(l<r){
                if(s1.charAt(l)!=s1.charAt(r)){
                    return false;
                }
                l++;
                r--;
            }
            return true;
        }
    }
    ```

20. <u>**验证回文串（可删除一次）**</u>：给定一个非空字符串 `s`，**最多**删除一个字符。判断是否能成为回文字符串。示例 1: 输入: "abca"； 输出: True

    ```java
    class Solution {
        public boolean validPalindrome(String s) {
            if(s==null){
                return false;
            }
            int l=0;
            int r=s.length()-1;
            while(l<r){
                if(s.charAt(l)!=s.charAt(r)){
                    break;
                }
                l++;
                r--;
            }
            if(l>=r){
                return true;
            }
            return judge(s,l+1,r)||judge(s,l,r-1);
        }
        
        public boolean judge(String s,int l,int r){
            while(l<=r){
                if(s.charAt(l)!=s.charAt(r)){
                    return false;
                }
                l++;
                r--;
            }
            return true;
        }
    }
    
    ```

21. <u>**统计字符串中回文子串的个数 **</u>：给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。示例 1：输入: "aaa"； 输出: 6。
    说明: 6个回文子串: "a", "a", "a", "aa", "aa", "aaa".

    **解题思路**：动态规划

    1、初始化以为数组 int[] res=int[n],他表示从0到i长度的子串回文子串的个数

    2、初始化边界边界条件：res[0]=1

    3、状态转移方程：res[i]=res[i-1]+ {i,i-1；i,i-2；i,i-3; ......i,0; 这几个子串是是回文的个数}；注意不要忘了i位置的字符自己就是个回文；

    4、返回最终结果：res[n-1]

    ```java
    class Solution {
        public int countSubstrings(String s) {
            if(s==null||s.length()==0){
                return 0;
            }
    
            int n=s.length();
            int[] res=new int[n];
            res[0]=1;
            for(int i=1;i<n;i++){
                int count=0;
                for(int j=0;j<=i;j++){
                    String subStr=s.substring(j,i+1);
                    if(judge(subStr)){
                        count++;
                    }
                }
                res[i]=res[i-1]+count;
            }
            return res[n-1];
        }
    
        public boolean judge(String str){
            int l=0;
            int r=str.length()-1;
            while(l<r){
                if(str.charAt(l)!=str.charAt(r)){
                    return false;
                }
                l++;
                r--;
            }
            return true;
        }
    }
    ```

    

22. <u>**返回字符串中最长的回文子串**</u>：给定一个非空字符串，返回该字符串中最长的回文子串。

    **解题思路**：递归的思路。注意递归和dfs的区别。

    ```java
    //思路一：递归会超时
    public class Solution {
        public static String longestPalindrome(String s){
            if(s==null||s.length()==0){
                return s;
            }
            
            int l=0,r=s.length()-1;
            if(judge(s,l,r)){
                return s.substring(l,r+1);
            }
            
            String strL=longestPalindrome(s.substring(l+1,r+1));
            String strR=longestPalindrome(s.substring(l,r));
            if(strL.length()>=strR.length()){
                return strL;
            }else{
                return strR;
            }
        }
    
        public static boolean judge(String s,int l,int r){
            while (l<r){
                if(s.charAt(l)!=s.charAt(r)){
                    return false;
                }
                l++;
                r--;
            }
            return true;
        }
    }
    //思路二：动态
    class Solution {
        public String longestPalindrome(String s) {
            int len = s.length();
            // 特判
            if (len < 2){
                return s;
            }
    
            int maxLen = 1;
            int begin  = 0;
    
            // 1. 状态定义
            // dp[i][j] 表示s[i...j] 是否是回文串
    
    
            // 2. 初始化
            boolean[][] dp = new boolean[len][len];
            for (int i = 0; i < len; i++) {
                dp[i][i] = true;
            }
    
            char[] chars = s.toCharArray();
            // 3. 状态转移
            // 注意：先填左下角
            // 填表规则：先一列一列的填写，再一行一行的填，保证左下方的单元格先进行计算
            for (int j = 1;j < len;j++){
                for (int i = 0; i < j; i++) {
                    // 头尾字符不相等，不是回文串
                    if (chars[i] != chars[j]){
                        dp[i][j] = false;
                    }else {
                        // 相等的情况下
                        // 考虑头尾去掉以后没有字符剩余，或者剩下一个字符的时候，肯定是回文串
                        if (j - i < 3){
                            dp[i][j] = true;
                        }else {
                            // 状态转移
                            dp[i][j] = dp[i + 1][j - 1];
                        }
                    }
    
                    // 只要dp[i][j] == true 成立，表示s[i...j] 是否是回文串
                    // 此时更新记录回文长度和起始位置
                    if (dp[i][j] && j - i + 1 > maxLen){
                        maxLen = j - i + 1;
                        begin = i;
                    }
                }
            }
            // 4. 返回值
            return s.substring(begin,begin + maxLen);
        }
    }
    ```

    

23. <u>**统计字符串中的单词数**</u>：统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。请注意，你可以假定字符串里不包括任何不可打印的字符。

    ```java
    class Solution {
        public int countSegments(String s) {
            String trimmed = s.trim();
            //因为"".split("\\s+")的话会得到一个长度为1的[""];
            if (trimmed.equals("")) {
                return 0;
            }
            //  \\s表示空格,回车,换行等空白符, +号表示一个或多个
            return trimmed.split("\\s+").length;
        }
    }
    
    ```

    

24. <u>**最常见的单词**</u>：给定一个段落 (paragraph) 和一个禁用单词列表 (banned)。返回出现次数最多，同时不在禁用列表中的单词。题目保证至少有一个词不在禁用列表中，而且答案唯一。

    禁用列表中的单词用小写字母表示，不含标点符号。段落中的单词不区分大小写。答案都是小写字母。示例：

    输入: paragraph = "Bob hit a ball, the hit BALL flew far after it was hit."
    banned = ["hit"]； 输出: "ball"

    **解题思路**：先处理paragraph，将其变成只包含小写字母的String[],然后通过哈希表，统计各个单词的出现次数。

    ```java
    class Solution {
        public String mostCommonWord(String paragraph, String[] banned) {
            HashMap<String,Integer> map=new HashMap<>();
            HashSet<String> set=new HashSet<>();
    
            //变为小写
            paragraph=paragraph.toLowerCase();
            String[] strArr=paragraph.trim().split(" ");
            for(int i=0;i<strArr.length;i++){
                //去掉符号
                String str=strArr[i];
                StringBuffer strbuf=new StringBuffer();
                for(int j=0;j<str.length();j++){
                    if(str.charAt(j)>='a'&&str.charAt(j)<='z'){
                        strbuf.append(str.charAt(j))
                    }
                }
                strArr[i]=strbuf.toString();
            }
    
            //用map对每个单词进行计数
            for(String str:strArr){
                if(!map.containsKey(str)){
                    map.put(str,0);
                }
                map.put(str,map.get(str)+1);
            }
            
            //把banned放到set里面
            for(String str:banned){
                set.add(str);
            }
            //找出符合条件的单词
            String res="";
            int max=0;
            for(String str:strArr){
                if(map.get(str)>max&&!set.contains(str)){
                    max=map.get(str);
                    res=str;
                }
            }
            return res;
        }
    }
    ```

25. <u>**实现indexOf()**</u>：给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。示例 1:  输入: haystack = "hello", needle = "ll"; 输出: 2

    **解题思路**:子串逐一比较法；需要注意边界处理的问题。

    ```java
    class Solution {
        public int strStr(String haystack, String needle) {
            //特例
            if((haystack==null||haystack.length()==0)&&(needle==null||needle.length()==0)){
                return 0;
            }
            if(haystack==null||haystack.length()==0){
                return -1;
            }
            if(needle==null||needle.length()==0){
                return 0;
            }
    
            //正常逻辑
            int n1=haystack.length();
            int n2=needle.length();
            for(int i=0;i<=n1-n2;i++){
                int j=i+n2;
                if(haystack.substring(i,j).equals(needle)){
                    return i;
                }
            }
            return -1;   
        }
    }
    ```

    

26. （看）<u>**最长公共前缀**</u>：编写一个函数来查找字符串数组中的最长公共前缀。

    如果不存在公共前缀，返回空字符串 ""。示例 1: 输入: ["flower","flow","flight"]； 输出: "fl"。

    **解题思路**：把它变成 flower

    ​                                    flow

    ​                                    flight

    ​					这样的形式，然后再进行处理

    ```java
    class Solution {
        public String longestCommonPrefix(String[] strs) {
            if(strs==null||strs.length==0){
                return "";
            }
    
            StringBuffer res=new StringBuffer();
            int n=strs.length;//行数
            int m=strs[0].length();//第一个元素的长度，列数
            for(int i=0;i<m;i++){//以其中一个元素为基准进行比较，行
                char ch=strs[0].charAt(i);
                for(int j=0;j<n;j++){//进行列方向的遍历列
                    if(i>=strs[j].length()){//如果strs的某个元素长度不够了，就直接返回结果
                        return res.toString();
                    }
                    if(strs[j].charAt(i)!=ch){//如果strs的某个元素的某个字符跟strs[0]相应位置的字符不相等了，就直接返回结果
                        return res.toString();
                    }
                }
                res.append(ch);
            }
            return res.toString();
        }
    }
    ```

27. <u>**亲密字符串**</u>：给定两个由小写字母构成的字符串 A 和 B ，只要我们可以通过交换 A 中的两个字母得到与 B 相等的结果，就返回 true ；否则返回 false 。

    示例 1：输入： A = "ab", B = "ba"； 输出： true。

    **解题思路**：只有两种情况返回true

    ​    1、AB中只有两个元素不等，这样调换一次位置之后能够相等；

    ​    2、AB相等，但是需要AB中存在重复的元素；

    ```java
    class Solution {
        public boolean buddyStrings(String A, String B) {
            //特殊情况
            if((A==null||A.length()<2)&&B==null||B.length()<2){
                return false;
            }
            if(A.length()!=B.length()){
                return false;
            }
    
            //正常，两个字符串长度相等
            int p=-1,q=-1;//记录两个不等的位置
            for(int i=0;i<A.length();i++){
                if(A.charAt(i)!=B.charAt(i)){
                    if(p==-1){
                        p=i;
                    }else if(q==-1){
                        q=i;
                    }else{//只能调换一次，如果超过两个字符不等的话，就直接返回false
                        return false;
                    }
                }
            }
            //到这里说明，要么AB相等，要么AB只有两个字符不等。
            
            if(p==-1&&q==-1){//这种情况是A和B是相等的时候，需要考虑A和B是否存在重复的元素
                for(int i=0;i<A.length();i++){
                    int first=A.indexOf(A.charAt(i));
                    int second=A.lastIndexOf(A.charAt(i));
                    if(first!=second){
                        return true;
                    }
                }
                return false;
            }
    
            if(A.charAt(p)==B.charAt(q)&&A.charAt(q)==B.charAt(p)){//这种情况，需要判断一下不等的位置是不是能够互换之后满足条件，
                return true;
            }
            return false;
        }
    }
    ```

28. <u>**有效的括号**</u>：给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效，有效字符串需满足：1、左括号必须用相同类型的右括号闭合；2、左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。

    示例 1: 输入: "()"；输出: true。
    示例 2: 输入: "()[]{}"； 输出: true。

    **解题思路**：如果是单一括号的匹配，直接维护一个left的计数器count就可以；左边放入count++，遇到右边的count--；最后count==0,返回true.

    这个题是多种括号，所以用栈来处理。

    还有一类括号的题，n对括号的所有排列方式，用dfs来做。

    ```java
    class Solution {
        public boolean isValid(String s) {
            if(s==null||s.length()==0){
                return true;
            }
    
            Stack<Character> stack=new Stack<>();
            for(int i=0;i<s.length();i++){
                if(s.charAt(i)=='('){
                    stack.push('(');
                }else if(s.charAt(i)=='['){
                    stack.push('[');
                }else if(s.charAt(i)=='{'){
                    stack.push('{');
                }else if(s.charAt(i)==')'){
                    if(stack.isEmpty()||stack.peek()!='('){
                        return false;
                    }
                    stack.pop();
                }else if(s.charAt(i)==']'){
                    if(stack.isEmpty()||stack.peek()!='['){
                        return false;
                    }
                    stack.pop();
                }else{
                    if(stack.isEmpty()||stack.peek()!='{'){
                        return false;
                    }
                    stack.pop();
                }
            }
    
            if(stack.isEmpty()){
                return true;
            }else{
                return false;
            }
        }
    }
    ```

29. <u>**n个括号的全排列**</u>：括号。设计一种算法，打印n对括号的所有合法的（例如，开闭一一对应）组合。说明：解集不能包含重复的子集。

    例如，给出 n = 3，生成结果为：

    [
      "((()))",
      "(()())",
      "(())()",
      "()(())",
      "()()()"
    ]

    **解题思路**：dfs，具体看回溯算法部分的例题

    ```java
    class Solution {
    
        List<String> res=new ArrayList<>();
        StringBuffer strBuf=new StringBuffer();
        public List<String> generateParenthesis(int n) {
            dfs(0,0,n);
            return res;
        }
        
        public void dfs(int l,int r,int max){
            if(l==max&&r==max){
                res.add(new String(strBuf));
                return ;
            }
            if(l<max){
                strBuf.append("(");
                dfs(l+1,r,max);
                strBuf.deleteCharAt(strBuf.length()-1);
            }
            if(r<l&&r<max){//r<l其实是剪枝的过程
                strBuf.append(")");
                dfs(l,r+1,max);
                strBuf.deleteCharAt(strBuf.length()-1);
            }
        }
    }
    ```

30. <u>**字符串的排列**</u>：输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。

    **解题思路**：dfs，具体见回溯里面的例题。

    ```java
    class Solution {
        List<Integer> path=new ArrayList<>();
        List<List<Integer>> res=new ArrayList<>();
        //他的作用是在dfs中for循环的时候，可以根据每一层选择出还没有被用过的元素
        boolean[] visited;
    
    public List<List<Integer>> permute(int[] nums) {
            int n=nums.length;
        	visited=new boolean[n];
            dfs(0,nums);//nums需要传到下面的函数
            return res;
        }
    
    public void dfs(int depth,int[] nums){
            int n=nums.length;
        	if(depth==n){
                //因为只记录最后一行的结果，所以在这里res.add(new ArrayList<>(path))
            	res.add(new ArrayList<>(path));
                return;
            }
            //这里的for循环是通过上面的策略树来决定的，在每一个深度，访问的是没有用过的值，所以这里for循环跟visited[]配合，可以达到这个效果。
            for(int i=0;i<n;i++){
                if(!visited[i]){
                    path.add(nums[i]);//作出选择
                    visited[i]=true;
                    dfs(depth+1,nums);//进入到下一层继续处理
                    path.remove(path.size()-1);//撤销选择
                    visited[i]=false;    
                }
            }
    
        }
    }
    ```

31. <u>**罗马数字转整数**</u>：罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

    字符          数值
    I             1
    V             5
    X             10
    L             50
    C             100
    D             500
    M             1000
    例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

    通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

    I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
    X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
    C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
    给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。

    示例 1: 输入: "LVIII"；输出: 58。解释: L = 50, V= 5, III = 3.

    示例2：输入:"DXL"；输出:540。解释: D=500,XL=40;

    **解题思路**：当前输入值需要通过后面的值来确定，如果cur小于next那么总和sum需要减去cur,如果大于，那么sum加上cur。

    ```java
    class Solution {
        public int romanToInt(String s) {
            if(s==null||s.length()==0){
                return 0;
            }
            Map<Character,Integer> map=new HashMap<>();
            map.put('I',1);
            map.put('V',5);
            map.put('X',10);
            map.put('L',50);
            map.put('C',100);
            map.put('D',500);
            map.put('M',1000);
    
            int sum=0;
            for(int i=0;i<s.length()-1;i++){
                int cur=map.get(s.charAt(i));
                int next=map.get(s.charAt(i+1));
                if(cur<next){
                    sum-=cur;
                }else{
                    sum+=cur;
                }   
            }
            sum+=map.get(s.charAt(s.length()-1));
            return sum;
        }
    }
    ```

    

32. <u>**整数转罗马数字**</u>：罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。

    ​		字符          数值
    ​		I             1
    ​		V             5
    ​		X             10
    ​		L             50
    ​		C             100
    ​		D             500
    ​		M             1000
    例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

    通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

    I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
    X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
    C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
    给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。

    示例 1: 输入: 58； 输出: "LVIII"。解释: L = 50, V = 5, III = 3.

    **解题思路**：贪心思想，num从大到小去匹配1000、900、500、。。。。，然后记录下来相应的符号。

    ```java
    class Solution {
        public String intToRoman(int num) {
            //不用map的原因是，map无序，且不好遍历，这也是map的缺点
            int[] value=new int[]{1000,900,500,400,100,90,50,40,10,9,5,4,1};
            String[] symbol=new String[]{"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"};
            StringBuffer res=new StringBuffer();
            for(int i=0;i<value.length&&num>0;i++){
                while(num>=value[i]){
                    res.append(symbol[i]);
                    num-=value[i];
                }
            }
            return res.toString();
        }
    }
    ```

    #### 

33. <u>**扑克牌顺子**</u>:LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)...他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子.....LL不高兴了,他想了想,决定大\小王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。

    **解题思路**:将这五个非零的元素放到，TreeSet里面，如果0的个数加上TreeSet.size()==5并且TreeSet里面的最大值减最小值小于5，set.last()-set.first()<5，这样就可以了。

    ```java
    import java.util.*;
    public class Solution {
        public boolean isContinuous(int [] numbers) {
            if(numbers.length!=5){
                return false;
            }
            
            int numOfZero=0;
            TreeSet<Integer> set=new TreeSet<>();
            for(int i=0;i<numbers.length;i++){
                if(numbers[i]==0){
                    numOfZero++;
                }else{
                    set.add(numbers[i]);
                }
            }
            
            if(numOfZero+set.size()!=5){
                return false;
            }
            if(set.last()-set.first()<5){
                return true;
            }
            return false;
        }
    }
    ```

    

    

    

    

    #### 进阶例题：

34. <u>**括号的分数**</u>：给定一个平衡括号字符串 S，按下述规则计算该字符串的分数：

    ​		() 得 1 分。
    ​		AB 得 A + B 分，其中 A 和 B 是平衡括号字符串。
    ​		(A) 得 2 * A 分，其中 A 是平衡括号字符串。

    示例 1： 输入： "(()(()))"； 输出： 6。
    **解题思路**：思路：动态＋栈的思想
    		字符串 S 中的每一个位置都有一个“深度”，即该位置外侧嵌套的括号数目。例如，字符串 (()(.())) 中的 . 的深度为 2，因为它外侧嵌套了 2 层括号：(__（.__))。
    		我们用一个栈来维护当前所在的深度，以及每一层深度的得分。当我们遇到一个左括号 ( 时，我们将深度加一，并且新的深度的得分置为 0。当我们遇到一个右括号 ) 时，我们将当前深度的得分乘二并加到上一层的深度。这里有一种例外情况，如果遇到的是 ()，那么只将得分加一。
    		下面给出了字符串 (()(())) 每次对应的栈的情况：
    		[0, 0] (
    		[0, 0, 0] ((
    		[0, 1] (()
    		[0, 1, 0] (()(
    		[0, 1, 0, 0] (()((
    		[0, 1, 1] (()(()
    		[0, 3] (()(())
    		[6] (()(()))


```java
class Solution {
    public int scoreOfParentheses(String S) {
        Stack<Integer> stack=new Stack<>();
        stack.push(0);
        for(char ch:S.toCharArray()){
            if(ch=='('){
                stack.push(0);
            }else{
                int lastn=stack.pop();
                int lastn_1=stack.pop();
                stack.push(lastn_1+Math.max(2*lastn,1));
            }
        }
        return stack.pop();
    }
}
```


​    

31. <u>**偶数个元音的最长子串**</u>：给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 'a'，'e'，'i'，'o'，'u' ，在子字符串中都恰好出现了偶数次。

    示例 1：输入：s = "eleetminicoworoep"；输出：13。解释：最长子字符串是 "leetminicowor" ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。

    **解题思路**：前缀和+状态压缩（位运算）。https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/solution/mei-ge-yuan-yin-bao-han-ou-shu-ci-de-zui-chang-z-2/

    ```java
    class Solution {
        public int findTheLongestSubstring(String s) {
            if(s==null||s.length()==0){
                return 0;
            }
            
            int ans=0;
            int status=0;
            int[] pos=new int[1<<5];//因为00000-11111，为0-31；所以这里POS的大小为32即可
            Arrays.fill(pos,-1);
            pos[0]=0;
    
            for(int i=0;i<s.length();i++){
                char ch=s.charAt(i);
                if(ch=='a'){
                    status^=(1<<0);
                }
                if(ch=='e'){
                    status^=(1<<1);
                }
                if(ch=='i'){
                    status^=(1<<2);
                }
                if(ch=='o'){
                    status^=(1<<3);
                }
                if(ch=='u'){
                    status^=(1<<4);
                }
    
                if(pos[status]>=0){
                    ans=Math.max(ans,i-pos[status]+1);
                }else{
                    pos[status]=i+1;//这个加1，是为了抵消最开始的-1；
                }
            }
            return ans;
    
        }
    }
    ```

    

32. <u>**构建回文串检测**</u>：给你一个字符串 s，请你对 s 的子串进行检测。

    ​		每次检测，待检子串都可以表示为 queries[i] = [left, right, k]。我们可以 重新排列 子串 s[left], ..., s[right]，并从中选择 最多 k 项替换成任何小写英文字母。 

    ​		如果在上述检测过程中，子串可以变成回文形式的字符串，那么检测结果为 true，否则结果为 false。

    ​		返回答案数组 answer[]，其中 answer[i] 是第 i 个待检子串 queries[i] 的检测结果。

    ​		注意：在替换时，子串中的每个字母都必须作为 独立的 项进行计数，也就是说，如果 s[left..right] = "aaa" 且 k = 2，我们只能替换其中的两个字母。（另外，任何检测都不会修改原始字符串 s，可以认为每次检测都是独立的）

    示例：

    输入：s = "abcda", queries = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]]
    输出：[true,false,false,true,true]
    解释：
    queries[0] : 子串 = "d"，回文。
    queries[1] : 子串 = "bc"，不是回文。
    queries[2] : 子串 = "abcd"，只替换 1 个字符是变不成回文串的。
    queries[3] : 子串 = "abcd"，可以变成回文的 "abba"。 也可以变成 "baab"，先重新排序变成 "bacd"，然后把 "cd" 替换为 "ab"。
    queries[4] : 子串 = "abcda"，可以变成回文的 "abcba"。

    **解题思路**：前缀和+状态压缩（位运算）

    ​		memo[i]代表子串s[0:i]中,各字符出现的奇偶性,用整数的后26位代表26个字母对应出现的奇偶性。如'a'出现奇数次,'b'偶数次,'c'奇数次,则memo[i] = 0b101。遍历s时,异或操作对应奇偶性变换。

    ​		对每个query, 计算 r = s[0:i] ^ s[o:j] 就是查询子串 s[i:j] 的字符奇偶性。

    求出r中为1的位个数,比较其除2 与 可替换字符个数的大小 就可以得到该次判断结果。

    ```java
    class Solution {
        public List<Boolean> canMakePaliQueries(String s, int[][] queries) {
            ArrayList<Boolean> list=new ArrayList<>();
            int len=s.length();
            int[] memo=new int[len];
            int tp=0;
            for(int i=0;i<len;i++){
                int bit=s.charAt(i)-'a';
                tp^=(1<<bit);
                memo[i]=tp;
            }
    
            for(int i=0;i<queries.length;i++){
                int left=queries[i][0];
                int right=queries[i][1];
                int r=0;
                if(left==0){
                    r=0^memo[right];
                }else{
                    r=memo[left-1]^memo[right];
                }
                int numOf1=0;
                while (r!=0){
                    numOf1++;
                    r=r&(r-1);
                }
                if(queries[i][2]>=numOf1/2){
                    list.add(true);
                }else{
                    list.add(false);
                }
            }
            return list;
        }
    }
    ```

33. 

34. 

35. 

36. 

37. 

38. 

39. 

40. 









